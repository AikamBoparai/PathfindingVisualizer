{"version":3,"sources":["logo.svg","PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/greedyBestFirst.js","algorithms/astar.js","algorithms/depthfirstsearch.js","PathfindingVisualizer/PathfindingVisualizer.jsx","algorithms/breadthfirstsearch.js","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","row","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","node","grid","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","push","length","filter","isVisited","getAllNodes","nodes","manhattanDistance","finishNode","currentNode","Math","abs","heuristic","sortNodesByHeuristic","updateUnvisitedNeighborsHeuristicDistance","sortNodesByHeuristicDistance","depthfirstsearch","startNode","visitedNodesInOrder","dfsHelper","i","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","state","mouseIsPressed","inAnimation","movingStart","movingEnd","finishedAnimation","getInitialGrid","setState","clickStart","clickFinish","document","getElementById","nodesInShortestPathOrder","select","timeout","setTimeout","animateShortestPath","time","updatedGrid","currentRow","createNode","resetPath","currentGrid","getUpdatedGrid","closestNode","shift","Infinity","dijkstra","greedyBestFirst","aStar","queue","breadthfirstsearch","unshift","getNodesInShortestPathOrder","animateDijkstra","newGrid","removePathElements","setStartFinishNodes","removeWalls","initial","removeWallElements","visitedNodes","getElementsByClassName","shortestNodes","wallNodes","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","onClick","resetGrid","visualize","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.488e7263.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      row,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : '';\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></div>\r\n    );\r\n  }\r\n}","export function dijkstra(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n\r\n    //Dijkstra's algorithm starts with the source node starting at zero\r\n    startNode.distance = 0;\r\n    //get all nodes and they'll have a distance of infinity\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    \r\n    //So keep looping until we visit all nodes, once we visit all nodes we stop\r\n    var counter = 0;\r\n    while (unvisitedNodes.length) {\r\n      //visit one node at time\r\n      sortNodesByDistance(unvisitedNodes);\r\n      //one Node will get popped off the array\r\n      const closestNode = unvisitedNodes.shift();\r\n      //if no other node is reachbale the algorithm has failed and there is no shortest path to the node\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n\r\n      //push the visitedNode onto the list\r\n      visitedNodesInOrder.push(closestNode);\r\n\r\n      //if the closest node is the finishNode, we've made it and can end the algorithm\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n      //Update the nodes based on distance, in dijkstra's terms, perform relaxation\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n  \r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  //find the node we are the smallest distance from and then we will select that one\r\n  // first step in dijkstra's algorithm\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n  \r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  //the neighbor to first visit will be the shortest path (relaxtion)\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    //make sure to keep track of the previous node so we determine the shortest path\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n  \r\nexport function getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    return neighbors.filter(neighbor => (!neighbor.isVisited) && (!neighbor.isWall));\r\n}\r\n  \r\nexport function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n  \r\n  // Backtracks from the finishNode to find the shortest path.\r\n  export function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      //adds to the array\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n\r\n      //get the previous node\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }","import{getUnvisitedNeighbors, getAllNodes} from './dijkstra';\r\nexport function greedyBestFirst(grid, startNode, finishNode){\r\n    startNode.heuristic = 0;\r\n    const visitedNodesInOrder = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    while(unvisitedNodes.length){\r\n        sortNodesByHeuristic(unvisitedNodes);\r\n\r\n        const closestNode = unvisitedNodes.shift();\r\n        if(closestNode.isWall)continue;\r\n        if(closestNode.heuristic === Infinity) return visitedNodesInOrder;\r\n\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n\r\n        if(closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n        updateUnvisitedNeighbors(closestNode, grid, finishNode);\r\n    }\r\n}\r\n\r\nexport function manhattanDistance(finishNode, currentNode){\r\n    return Math.abs(finishNode.col - currentNode.col) + Math.abs(finishNode.row - currentNode.row);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, finishNode){\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      neighbor.heuristic = manhattanDistance(finishNode, neighbor);\r\n      //make sure to keep track of the previous node so we determine the shortest path\r\n      neighbor.previousNode = node;\r\n    }\r\n}\r\n\r\nfunction sortNodesByHeuristic(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.heuristic - nodeB.heuristic);\r\n}\r\n","import{getUnvisitedNeighbors} from './dijkstra';\r\nimport{manhattanDistance} from './greedyBestFirst';\r\nimport{getAllNodes} from './dijkstra';\r\nexport function aStar(grid, startNode, finishNode){\r\n    startNode.heuristic = 0;\r\n    startNode.distance = 0;\r\n    const visitedNodesInOrder = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    while(unvisitedNodes.length){\r\n        sortNodesByHeuristicDistance(unvisitedNodes);\r\n\r\n        const closestNode = unvisitedNodes.shift();\r\n        if(closestNode.heuristic === Infinity || closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        if(closestNode.isWall)continue;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n\r\n        if(closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n        updateUnvisitedNeighborsHeuristicDistance(closestNode, grid, finishNode);\r\n    }\r\n}\r\n\r\nfunction updateUnvisitedNeighborsHeuristicDistance(node, grid, finishNode){\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      neighbor.heuristic = manhattanDistance(finishNode, neighbor);\r\n      neighbor.distance = node.distance + 1;\r\n      //make sure to keep track of the previous node so we determine the shortest path\r\n      neighbor.previousNode = node;\r\n    }\r\n}\r\n\r\nfunction sortNodesByHeuristicDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA, nodeB) => (nodeA.heuristic - nodeB.heuristic) + (nodeA.distance - nodeB.distance));\r\n}\r\n\r\n","import{getUnvisitedNeighbors} from './dijkstra';\r\nexport function depthfirstsearch(grid, startNode, finishNode){\r\n    const visitedNodesInOrder = [];\r\n    dfsHelper(visitedNodesInOrder, startNode, grid, finishNode)\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction dfsHelper(visitedNodesInOrder, node, grid, finishNode){\r\n    if(visitedNodesInOrder[visitedNodesInOrder.length - 1] === finishNode)return;\r\n\r\n    visitedNodesInOrder.push(node);\r\n    node.isVisited = true;\r\n\r\n   const neighbors = getUnvisitedNeighbors(node, grid);\r\n   for(let i = 0; i < neighbors.length; i++){\r\n       if(visitedNodesInOrder[visitedNodesInOrder.length - 1] !== finishNode){\r\n           neighbors[i].previousNode = node;\r\n       }\r\n       dfsHelper(visitedNodesInOrder, neighbors[i], grid, finishNode);\r\n   }\r\n}","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dijkstra';\r\nimport {greedyBestFirst} from '../algorithms/greedyBestFirst';\r\nimport {aStar} from '../algorithms/astar';\r\nimport {depthfirstsearch} from '../algorithms/depthfirstsearch';\r\nimport {breadthfirstsearch} from '../algorithms/breadthfirstsearch';\r\nimport './PathfindingVisualizer.css';\r\n\r\nvar START_NODE_ROW = 10;\r\nvar START_NODE_COL = 15;\r\nvar FINISH_NODE_ROW = 10;\r\nvar FINISH_NODE_COL = 45;\r\n\r\nconst NUM_ROWS = 22;\r\nconst NUM_COLS = 55;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      inAnimation: false,\r\n      movingStart: false,\r\n      movingEnd: false,\r\n      finishedAnimation: false,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({grid});\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    //Detects when we press the mouse inside a node\r\n    //const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    var clickStart = false;\r\n    var clickFinish = false;\r\n    if(row === START_NODE_ROW && col === START_NODE_COL){\r\n        clickStart = true;\r\n    }\r\n    else if(row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\r\n      clickFinish = true;\r\n    }\r\n    else{\r\n      const node = document.getElementById(\"node-\" + row + \"-\" + col);\r\n      node.className = node.className === \"node \" ? \"node node-wall\" : \r\n      node.className === \"node node-start\" || node.className === \"node node-finish\" ? node.className : \"node \";\r\n    }\r\n    this.setState({mouseIsPressed: true, movingStart: clickStart, movingEnd: clickFinish});\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    if(this.state.movingStart && !(row === FINISH_NODE_ROW && col === FINISH_NODE_COL)){\r\n        const currentStart = document.getElementById(\"node-\"+START_NODE_ROW +\"-\"+ START_NODE_COL);\r\n        currentStart.className = \"node \";\r\n        START_NODE_ROW = row;\r\n        START_NODE_COL = col;\r\n        const newStart = document.getElementById(\"node-\"+START_NODE_ROW +\"-\"+ START_NODE_COL);\r\n        newStart.className = \"node node-start\";\r\n    }\r\n    else if(this.state.movingEnd && !(row === START_NODE_ROW && col === START_NODE_COL)){\r\n        const currentStart = document.getElementById(\"node-\"+FINISH_NODE_ROW +\"-\"+ FINISH_NODE_COL);\r\n        currentStart.className = \"node \";\r\n        FINISH_NODE_ROW = row;\r\n        FINISH_NODE_COL = col;\r\n        const newStart = document.getElementById(\"node-\"+FINISH_NODE_ROW +\"-\"+ FINISH_NODE_COL);\r\n        newStart.className = \"node node-finish\";\r\n    }\r\n    else{\r\n      const node = document.getElementById(\"node-\" + row + \"-\" + col);\r\n      node.className = node.className === \"node \" ? \"node node-wall\" : \r\n      node.className === \"node node-start\" || node.className === \"node node-finish\" ? node.className : \"node \";\r\n    }\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({mouseIsPressed: false, movingStart: false});\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder, select) {\r\n    //go through the visited nodes in order\r\n    var timeout;\r\n    switch(select){\r\n      case \"Dijkstra\":\r\n        timeout = 5;\r\n        break;\r\n      case \"GBFS\":\r\n        timeout = 15;\r\n        break;\r\n      case \"A*\":\r\n        timeout = 10;\r\n        break;\r\n      case \"DFS\":\r\n        timeout = 5;\r\n        break;\r\n      case \"BFS\":\r\n        timeout = 5;\r\n        break;\r\n      default:\r\n        timeout = 10;\r\n    }\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      //once we reach the end of visiting nodes, then we can start the shortest path\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, timeout * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-visited';\r\n      }, timeout * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder, time) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-shortest-path';\r\n        if(i === nodesInShortestPathOrder.length - 1){\r\n          this.setState({inAnimation: false});\r\n        }\r\n      }, 40 * i);\r\n    }\r\n  }\r\n\r\n  getUpdatedGrid(){\r\n      const updatedGrid = [];\r\n\r\n      for(let row = 0; row < NUM_ROWS; row++){\r\n        const currentRow = [];\r\n        for(let col = 0; col < NUM_COLS ; col++){\r\n          const node = createNode(col, row);\r\n          const className = document.getElementById(\"node-\" + row + \"-\" + col).className;\r\n\r\n          if(className === \"node node-visited\"){\r\n            node.isVisited = true;\r\n          }\r\n\r\n          else if(className === \"node node-wall\"){\r\n            node.isWall = true;\r\n          }\r\n\r\n          currentRow.push(node);\r\n        }\r\n\r\n        updatedGrid.push(currentRow);\r\n      }\r\n\r\n      return updatedGrid;\r\n  }\r\n\r\n  visualize(select) {\r\n    if(this.state.inAnimation)return;\r\n    if(this.state.finishedAnimation)this.resetPath();\r\n    const currentGrid = this.getUpdatedGrid();\r\n    this.setState({grid:currentGrid,inAnimation: true});\r\n    const startNode = currentGrid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = currentGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = select === \"Dijkstra\" ? dijkstra(currentGrid, startNode, finishNode) \r\n    :select === \"GBFS\" ? greedyBestFirst(currentGrid, startNode, finishNode)\r\n    :select === \"A*\" ? aStar(currentGrid, startNode, finishNode)\r\n    :select === \"DFS\" ?  depthfirstsearch(currentGrid, startNode, finishNode)\r\n    :breadthfirstsearch(currentGrid, startNode, finishNode);\r\n    ;\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder, select);\r\n    this.setState({finishedAnimation: true});\r\n  }\r\n\r\n  resetPath(){\r\n    if(this.state.inAnimation)return;\r\n    const newGrid = getInitialGrid();\r\n    //keep walls\r\n    for(let row = 0; row < NUM_ROWS; row++){\r\n      for(let col = 0; col < NUM_COLS; col ++){\r\n        if(this.state.grid[row][col].isWall){\r\n          newGrid[row][col].isWall = true;\r\n        }\r\n      }\r\n    }\r\n    this.removePathElements();\r\n    this.setStartFinishNodes();\r\n    this.setState({grid: newGrid, mouseIsPressed: false, finishedAnimation: false});    \r\n  }\r\n\r\n  resetGrid(){\r\n    if(this.state.inAnimation)return;\r\n    this.removeWalls();\r\n    this.resetPath();\r\n    this.setStartFinishNodes();\r\n\r\n    var initial = getInitialGrid();\r\n    this.setState({grid: initial, mouseIsPressed: false, finishedAnimation:false});\r\n  }\r\n\r\n  removeWalls(){\r\n    if(this.state.inAnimation)return;\r\n      const newGrid = getInitialGrid();\r\n      for(let row = 0; row < NUM_ROWS; row++){\r\n        for(let col = 0; col < NUM_COLS; col ++){\r\n          if(this.state.grid[row][col].isVisited){\r\n            newGrid[row][col].isVisited = true;\r\n          }\r\n          \r\n        }\r\n      }\r\n      this.removeWallElements();\r\n      this.setStartFinishNodes();\r\n\r\n      this.setState({grid: newGrid, mouseIsPressed:false});\r\n  }\r\n\r\n  removePathElements(){\r\n    if(this.state.inAnimation)return;\r\n    var visitedNodes = document.getElementsByClassName('node node-visited');\r\n    while(visitedNodes.length > 0){\r\n      for(let i = 0; i < visitedNodes.length; i++){\r\n        visitedNodes[i].className = \"node \";\r\n      }\r\n      visitedNodes = document.getElementsByClassName('node node-visited');\r\n    }\r\n\r\n    var shortestNodes = document.getElementsByClassName('node node-shortest-path');\r\n    while(shortestNodes.length > 0){\r\n      for(let i = 0; i < shortestNodes.length; i++){\r\n        shortestNodes[i].className = \"node \";\r\n      }\r\n      shortestNodes = document.getElementsByClassName('node node-shortest-path');\r\n    }\r\n\r\n  }\r\n\r\n  removeWallElements(){\r\n    var wallNodes = document.getElementsByClassName('node node-wall');\r\n    while(wallNodes.length > 0){\r\n      for(let i = 0; i < wallNodes.length; i++){\r\n        wallNodes[i].className = \"node \";\r\n      }\r\n      wallNodes = document.getElementsByClassName('node node-wall');\r\n    }\r\n  }\r\n\r\n  setStartFinishNodes(){\r\n    const startNode = document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`);\r\n    const finishNode = document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`);\r\n\r\n    startNode.className = 'node node-start';\r\n    finishNode.className = 'node node-finish';\r\n  }\r\n\r\n  render() {\r\n    const {grid, mouseIsPressed} = this.state;\r\n\r\n    return (\r\n      <>\r\n        <header className=\"bd-header bg-dark py-3 d-flex align-items-stretch border-bottom border-dark\">\r\n          <div className=\"container-fluid d-flex align-items-center\">\r\n            <h1 className=\"d-flex align-items-center fs-4 text-white mb-0\">\r\n              Pathfinding Visualizer\r\n            </h1>\r\n          </div>\r\n      </header>\r\n        <div id=\"container-guide\">\r\n          <ul>\r\n            <li>Start Node  <div className=\"dStart display\"></div></li>\r\n            <li>Finish Node <div className=\"dFinish display\"></div></li>\r\n            <li>Empty Node <div className=\"dEmpty display\"></div></li>\r\n            <li>Wall Node  <div className=\"dWall display\"></div></li>\r\n            <li>Visited Node  <div className=\"dVisit display\"></div></li>\r\n            <li>Shortest Path Node  <div className=\"dShort display\"></div></li>\r\n          </ul>\r\n        </div>\r\n        <div className=\"grid\">\r\n        <p>Click to add walls!</p>\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {row, col, isFinish, isStart, isWall} = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                      row={row}></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n              \r\n            );\r\n          })}\r\n        </div>\r\n        <button className=\"reset ghost\" onClick={() => this.resetGrid()}>Reset Grid</button>\r\n        <button className=\"path ghost\" onClick={() => this.resetPath()}>Clear Path</button>\r\n        <button className=\"walls ghost\" onClick={() => this.removeWalls()}>Clear Walls</button>\r\n        <button className=\"dijkstra animated\" onClick={() => this.visualize(\"Dijkstra\")}>\r\n          Visualize Dijkstra's Algorithm\r\n        </button>\r\n        <button className=\"greedy animated\" onClick={() => this.visualize(\"GBFS\")}>\r\n          Visualize Greedy Best First Search\r\n        </button>\r\n        <button className=\"aStar animated\" onClick={() => this.visualize(\"A*\")}>\r\n          Visualize A*\r\n        </button>\r\n        <button className=\"dfs animated\" onClick={() => this.visualize(\"DFS\")}>\r\n          Visualize DFS\r\n        </button>\r\n        <button className=\"bfs animated\" onClick={() => this.visualize(\"BFS\")}>\r\n          Visualize BFS\r\n        </button>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < NUM_ROWS; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < NUM_COLS; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    heuristic: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    distance: Infinity,\r\n    previousNode: null,\r\n  };\r\n};","import{getUnvisitedNeighbors} from './dijkstra';\r\nexport function breadthfirstsearch(grid, startNode, finishNode){\r\n    const visitedNodesInOrder = [];\r\n    const queue = [];\r\n\r\n    startNode.isVisited = true;\r\n    queue.push(startNode);\r\n\r\n    while(queue.length > 0){\r\n        var node = queue.shift();\r\n        visitedNodesInOrder.push(node);\r\n        if(node.isFinish)break;\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n\r\n        for(let i = 0; i < unvisitedNeighbors.length; i++){\r\n            unvisitedNeighbors[i].isVisited = true;\r\n            unvisitedNeighbors[i].previousNode = node;\r\n            queue.push(unvisitedNeighbors[i]);\r\n        }\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n}","import logo from './logo.svg';\r\nimport './App.css';\r\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer.jsx';\r\n\r\nfunction App() {\r\n  return (\r\n      <div className=\"App\">\r\n        <PathfindingVisualizer></PathfindingVisualizer>\r\n      </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}